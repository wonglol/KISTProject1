#!/usr/bin/env python3
# meep_fiber2six_array.py
# 3D FDTD in MEEP: fiber (step-index cylinder) -> 6-waveguide (2-layer x 3) array
# Computes per-facet coupling efficiency via eigenmode decomposition.
# Units: micron (um)

import meep as mp
import numpy as np

# -----------------------------
# User parameters (edit here)
# -----------------------------
params = {
    # Spectral setup
    "lambda_cen": 1.575,     # center wavelength [um] (paper peak ~1575 nm)
    "fwidth_rel": 0.04,      # fractional bandwidth of Gaussian pulse (~4%)
    # Fiber geometry (step-index)
    "fiber_core_n": 1.449,   # ~silica core (approx); adjust to your datasheet
    "fiber_clad_n": 1.4449,  # ~silica cladding / index-matching region
    "fiber_core_radius": 4.30,     # PM-1550 core radius ~4.25–4.3 um (paper discussion)
    "fiber_clad_radius": 8.50,     # truncated cladding radius used in sim (Fig.1(a) shows 8.5 um)
    "fiber_length": 8.0,           # finite fiber length inside cell [um]
    "fiber_gap": 0.2,              # fiber facet-to-chip facet gap [um] (filled with index-matching fluid)
    # Six-WG array (SiN-on-oxide), two layers
    "n_core": 2.0,            # SiN ~2.0 (non-dispersive approx)
    "n_clad": 1.4449,         # SiO2
    "t_core": 0.08,           # each SiN layer thickness [um] ~80 nm (paper)
    "t_mid": 0.60,            # inter-layer oxide thickness between two SiN layers [um] (tune)
    "pitch": 2.20,            # lateral pitch between adjacent WGs [um] (paper Fig.5 caption)
    "w_center": 0.561,        # center WG width [um] (paper best case)
    "w_outer": 0.490,         # outer WG width [um] (paper best case)
    # Array length after the facet (constant cross-section region)
    "array_length": 6.0,      # [um] propagation region to place output monitor
    # Domain / mesh
    "pad_y": 3.0,             # side padding beyond outermost WG [um]
    "pad_z_top": 3.0,         # top oxide thickness above upper layer [um]
    "pad_z_bot": 3.0,         # bottom oxide thickness below lower layer [um]
    "pml_thick": 2.0,         # PML thickness [um]
    "resolution": 50,         # pixels per um (20 nm grid). For production: 60–80.
    # Monitors
    "mon_in_shift":  -(2.0),  # input mode monitor position relative to chip facet (in fiber) [um]
    "mon_out_shift":  1.0,    # output mode monitor position inside array from facet [um]
}

#--------------------------------
#Derived quantities
#--------------------------------
um=1.0
fcen = 1.0/params["lambda_cen"]
df = params["fwidth_rel"]*fcen

# Convenience media
sio2 = mp.Medium(index=params["n_clad"]) #used to create a material object by mp.Medium. The refractive index is being set by the value of params["n_clad"]
sin = mp.Medium(index=params["n_core"]) # used to create SiN material object. The refractive index is set as 2
fiber_core = mp.Medium(index=params["fiber_core_n"]) # used to create a material object called fiber_core. The refractive index is set as 1.449

# Cell size(x along propagation; y lateral; z vertical)
# Left: fiber start -> fiber facet -> gap -> chip facet -> array region -> PML
left_len = params["fiber_length"] + params["fiber_gap"] #the length of the input section, which includes an optical fiber and a small fiber gap before the chip
right_len = params["array_length"] #the length of the main device being simulated (array_length)
sx = left_len + right_len + 2*params["pml_thick"] 
#total length of the simulation cell along the direction of light propagation the thickness of the PMLs at both the start and end of the x-axis.

# y-span to include 3 WGs per layer with pitch plus margin
# calculates the total width of the simulation cell. The comments suggest the setup is wide enough to inlcude three parallel waveguides.
# The calculation is done by figuring out the span from the center to one edge and then doubling it. The span from the center outwards includes:
wg_half_span = params["pitch"] # from center to outer WG center
sy = 2*(wg_half_span + params["w_outer"]/2.0 + params["pad_y"] + 2*params["pml_thick"]) 
# params["pitch"]: The distance from the central waveguide to an outer waveguide, params["w_outer"]/2.0: Half of the width of the outer waveguide, to get to its outer edge.
# params["pad_y"]: Extra padding space to the margin,  

# z-span:two layers around z=±t_mid/2 with t_core thickness; add oxide above/below
# Calculates the total vertical extent from the bottom edge of the lower core layer to the top edge of the upper core layer.
z_upper = (+0.5*params["t_mid"] + 0.5*params["t_core"]) #vertical distance between the centers of the two cores + thickness of individual core
z_lower = (-0.5*params["t_mid"] - 0.5*params["t_core"]) #starts at the center of the lower core (-0.5*t_mid) and subtracts half its thickness (-0.5*t_core) to find its bottom surface
sz = (params["pad_z_top"] +(z_upper + params["t_core"]/2) # room above upper core
    -(z_lower - params["t_core"]/2) + params["pad_z_bot"]) + 2*params["pml_thick"]

#Absolute x-positions (facet at x=0)
x_pml_left = -0.5*sx + params["pml_thick"] #coordinates for the inner edges of the PMLs.
x_pml_right = +0.5*sx - params["pml_thick"]
x_fiber_start = x_pml_left
x_fiber_end = -params["fiber_gap"]    #fiber facet (end of cylinder)
x_chip_facet = 0.0    #start of waveguide array
x_array_end = params["array_length"]

#Source plane inside fiber (where geometry is invariant)
x_src = x_chip_facet + params["mou_in_shift"]

#Mode monitors
x_mon_in = x_chip_facet + params["mon_in_shift"]
x_mon_out = x_chip_facet + params["mon_out_shift"]

#-------------------
#Geometry definition
#-------------------
geometry = []

#Default medium is SiO2 (oxide): chip claddings, fiber cladding, and gap are oxide
default_material = sio2

#Fiber core: cylinder along x-axis (propagation axis)
geometry += [
    mp.Cylinder(
        center = mp.Vector3(0.5*(x_fiber_start + x_fiber_end),0,0), #centered in x over fiber length
        radius = params["fiber_core_radius"],
        height=abs(x_fiber_end - x_fiber_start),
        axis=mp.Vector3(1,0,0), # along x
        material = fiber_core
    )
]
