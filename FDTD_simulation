#!/usr/bin/env python3
# meep_fiber2six_array.py
# 3D FDTD in MEEP: fiber (step-index cylinder) -> 6-waveguide (2-layer x 3) array
# Computes per-facet coupling efficiency via eigenmode decomposition.
# Units: micron (um)

import meep as mp
import numpy as np

# -----------------------------
# User parameters (edit here)
# -----------------------------
params = {
    # Spectral setup
    "lambda_cen": 1.575,     # center wavelength [um] (paper peak ~1575 nm)
    "fwidth_rel": 0.04,      # fractional bandwidth of Gaussian pulse (~4%)
    # Fiber geometry (step-index)
    "fiber_core_n": 1.449,   # ~silica core (approx); adjust to your datasheet
    "fiber_clad_n": 1.4449,  # ~silica cladding / index-matching region
    "fiber_core_radius": 4.30,     # PM-1550 core radius ~4.25–4.3 um (paper discussion)
    "fiber_clad_radius": 8.50,     # truncated cladding radius used in sim (Fig.1(a) shows 8.5 um)
    "fiber_length": 8.0,           # finite fiber length inside cell [um]
    "fiber_gap": 0.2,              # fiber facet-to-chip facet gap [um] (filled with index-matching fluid)
    # Six-WG array (SiN-on-oxide), two layers
    "n_core": 2.0,            # SiN ~2.0 (non-dispersive approx)
    "n_clad": 1.4449,         # SiO2
    "t_core": 0.08,           # each SiN layer thickness [um] ~80 nm (paper)
    "t_mid": 0.60,            # inter-layer oxide thickness between two SiN layers [um] (tune)
    "pitch": 2.20,            # lateral pitch between adjacent WGs [um] (paper Fig.5 caption)
    "w_center": 0.561,        # center WG width [um] (paper best case)
    "w_outer": 0.490,         # outer WG width [um] (paper best case)
    # Array length after the facet (constant cross-section region)
    "array_length": 6.0,      # [um] propagation region to place output monitor
    # Domain / mesh
    "pad_y": 3.0,             # side padding beyond outermost WG [um]
    "pad_z_top": 3.0,         # top oxide thickness above upper layer [um]
    "pad_z_bot": 3.0,         # bottom oxide thickness below lower layer [um]
    "pml_thick": 2.0,         # PML thickness [um]
    "resolution": 50,         # pixels per um (20 nm grid). For production: 60–80.
    # Monitors
    "mon_in_shift":  -(2.0),  # input mode monitor position relative to chip facet (in fiber) [um]
    "mon_out_shift":  1.0,    # output mode monitor position inside array from facet [um]
}

#--------------------------------
#Derived quantities
#--------------------------------
um=1.0
fcen = 1.0/params["lambda_cen"]
df = params["fwidth_rel"]*fcen

# Convenience media
sio2 = mp.Medium(index=params["n_clad"]) #used to create a material object by mp.Medium. The refractive index is being set by the value of params["n_clad"]
sin = mp.Medium(index=params["n_core"]) # used to create SiN material object. The refractive index is set as 2
fiber_core = mp.Medium(index=params["fiber_core_n"]) # used to create a material object called fiber_core. The refractive index is set as 1.449

# Cell size(x along propagation; y lateral; z vertical)
# Left: fiber start -> fiber facet -> gap -> chip facet -> array region -> PML
left_len = params["fiber_length"] + params["fiber_gap"] #the length of the input section, which includes an optical fiber and a small fiber gap before the chip
right_len = params["array_length"] #the length of the main device being simulated (array_length)
sx = left_len + right_len + 2*params["pml_thick"] 
#total length of the simulation cell along the direction of light propagation the thickness of the PMLs at both the start and end of the x-axis.

# y-span to include 3 WGs per layer with pitch plus margin
# calculates the total width of the simulation cell. The comments suggest the setup is wide enough to inlcude three parallel waveguides.
# The calculation is done by figuring out the span from the center to one edge and then doubling it. The span from the center outwards includes:
wg_half_span = params["pitch"] # from center to outer WG center
sy = 2*(wg_half_span + params["w_outer"]/2.0 + params["pad_y"] + 2*params["pml_thick"]) 
# params["pitch"]: The distance from the central waveguide to an outer waveguide, params["w_outer"]/2.0: Half of the width of the outer waveguide, to get to its outer edge.
# params["pad_y"]: Extra padding space to the margin,  

# z-span:two layers around z=±t_mid/2 with t_core thickness; add oxide above/below
# Calculates the total vertical extent from the bottom edge of the lower core layer to the top edge of the upper core layer.
z_upper = (+0.5*params["t_mid"] + 0.5*params["t_core"]) #vertical distance between the centers of the two cores + thickness of individual core
z_lower = (-0.5*params["t_mid"] - 0.5*params["t_core"]) #starts at the center of the lower core (-0.5*t_mid) and subtracts half its thickness (-0.5*t_core) to find its bottom surface
sz = (params["pad_z_top"] +(z_upper + params["t_core"]/2) # room above upper core
    -(z_lower - params["t_core"]/2) + params["pad_z_bot"]) + 2*params["pml_thick"]

#Absolute x-positions (facet at x=0)
x_pml_left = -0.5*sx + params["pml_thick"] #coordinates for the inner edges of the PMLs.
x_pml_right = +0.5*sx - params["pml_thick"]
x_fiber_start = x_pml_left
x_fiber_end = -params["fiber_gap"]    #fiber facet (end of cylinder)
x_chip_facet = 0.0    #start of waveguide array
x_array_end = params["array_length"]

#Source plane inside fiber (where geometry is invariant)
x_src = x_chip_facet + params["mou_in_shift"]

#Mode monitors
x_mon_in = x_chip_facet + params["mon_in_shift"]
x_mon_out = x_chip_facet + params["mon_out_shift"]

#-------------------
#Geometry definition
#-------------------
geometry = []

#Default medium is SiO2 (oxide): chip claddings, fiber cladding, and gap are oxide
default_material = sio2

#Fiber core: cylinder along x-axis (propagation axis)
geometry += [
    mp.Cylinder(
        center = mp.Vector3(0.5*(x_fiber_start + x_fiber_end),0,0), #centered in x over fiber length
        radius = params["fiber_core_radius"],
        height=abs(x_fiber_end - x_fiber_start),
        axis=mp.Vector3(1,0,0), # along x
        material = fiber_core
    )
]

# Fiber core: cylinder along x-axis (propagation axis)
geometry += [
    mp.Cylinder(
        center=mp.Vector3(0.5*(x_fiber_start + x_fiber_end), 0, 0),    # centered in x over fiber length
        radius=params["fiber_core_radius"],
        height=abs(x_fiber_end - x_fiber_start),
        axis=mp.Vector3(1, 0, 0),  # along x
        material=fiber_core
    )
]

# Six SiN waveguides (constant cross-section segment after chip facet)
# Layer centers in z: ±(t_mid/2)
z_layer_up   = +0.5*params["t_mid"]
z_layer_down = -0.5*params["t_mid"]

# common helper to add one rectangular WG bar extruded along x
def add_wg(yc, zc, width_y):
    geometry.append(
        mp.Block(
            size=mp.Vector3(x_array_end - x_chip_facet, width_y, params["t_core"]),
            center=mp.Vector3(0.5*(x_chip_facet + x_array_end), yc, zc),
            material=sin
        )
    )

# y-positions for three WGs per layer: [-pitch, 0, +pitch]
ys = [-params["pitch"], 0.0, +params["pitch"]]

# Upper layer: center uses w_center; outers use w_outer
add_wg(ys[1], z_layer_up,   params["w_center"])
add_wg(ys[0], z_layer_up,   params["w_outer"])
add_wg(ys[2], z_layer_up,   params["w_outer"])
# Lower layer:
add_wg(ys[1], z_layer_down, params["w_center"])
add_wg(ys[0], z_layer_down, params["w_outer"])
add_wg(ys[2], z_layer_down, params["w_outer"])

# -----------------------------
# Sources (fiber LP01 eigenmode)
# -----------------------------
sources = [
    mp.EigenModeSource(
        src=mp.GaussianSource(frequency=fcen, fwidth=df),
        center=mp.Vector3(x_src, 0, 0),
        size=mp.Vector3(0, sy-2*params["pml_thick"], sz-2*params["pml_thick"]),  # cross-section plane
        direction=mp.X,               # +x propagation
        eig_band=1,                   # fundamental fiber mode
        eig_parity=mp.NO_PARITY,      # 3D: let MEEP choose
        eig_match_freq=True
    )
]

# -----------------------------
# Simulation object
# -----------------------------
sim = mp.Simulation(
    cell_size=mp.Vector3(sx, sy, sz),
    boundary_layers=[mp.PML(params["pml_thick"])],
    geometry=geometry,
    sources=sources,
    resolution=params["resolution"],
    default_material=default_material,
    symmetries=[] # no symmetry (fiber + 2-layer is symmetric but keep general)
)

# -----------------------------
# Mode monitors for Pin/Pout
# -----------------------------
mon_in = sim.add_mode_monitor(
    fcen, 0, 1,
    mp.ModeRegion(center=mp.Vector3(x_mon_in, 0, 0),
                  size=mp.Vector3(0, sy-2*params["pml_thick"], sz-2*params["pml_thick"]))
)

mon_out = sim.add_mode_monitor(
    fcen, 0, 1,
    mp.ModeRegion(center=mp.Vector3(x_mon_out, 0, 0),
                  size=mp.Vector3(0, sy-2*params["pml_thick"], sz-2*params["pml_thick"]))
)

# -----------------------------
# Run
# -----------------------------
# Stop when fields decay at a point in the output region (pulsed source)
probe_pt = mp.Vector3(x_mon_out + 0.5, 0, 0)

sim.run(until_after_sources=mp.stop_when_fields_decayed(
    50, mp.Ez, probe_pt, 1e-7)
)

# -----------------------------
# Post-processing: Coupling efficiency
# -----------------------------
# Expand fields onto local eigenmodes at each monitor.
# band=1 corresponds to fundamental mode in that cross section:
# - 'mon_in': fiber LP01
# - 'mon_out': 6-WG supermode (fundamental TE-like of the array)
coeff_in  = sim.get_eigenmode_coefficients(mon_in,  [1])
coeff_out = sim.get_eigenmode_coefficients(mon_out, [1])

# alpha are forward-going amplitudes; power ~ |alpha|^2
a_in  = coeff_in.alpha[0,0,0]   # [mode_index, frequency_index, component]
a_out = coeff_out.alpha[0,0,0]

P_in  = np.abs(a_in)**2
P_out = np.abs(a_out)**2
eta   = P_out / P_in

